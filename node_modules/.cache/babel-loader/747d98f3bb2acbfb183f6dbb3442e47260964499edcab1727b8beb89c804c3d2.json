{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useState, useEffect, useRef } from 'react';\nconst useSpeechRecognition = ({\n  onResult,\n  onError\n}) => {\n  _s();\n  const [isListening, setIsListening] = useState(false);\n  const recognitionRef = useRef(null);\n  const transcriptRef = useRef('');\n  useEffect(() => {\n    if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {\n      const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;\n      recognitionRef.current = new SpeechRecognition();\n      recognitionRef.current.continuous = true;\n      recognitionRef.current.interimResults = true;\n      recognitionRef.current.onresult = event => {\n        let interimTranscript = '';\n        let finalTranscript = transcriptRef.current;\n        for (let i = event.resultIndex; i < event.results.length; i++) {\n          const transcript = event.results[i][0].transcript;\n          if (event.results[i].isFinal) {\n            finalTranscript += transcript + ' ';\n          } else {\n            interimTranscript += transcript;\n          }\n        }\n\n        // Update the reference to maintain state between callback executions\n        transcriptRef.current = finalTranscript;\n\n        // Call the onResult callback with the combined transcript\n        onResult(finalTranscript || interimTranscript);\n      };\n      recognitionRef.current.onerror = event => {\n        console.error('Speech recognition error', event.error);\n        onError(event.error);\n        setIsListening(false);\n      };\n    } else {\n      onError('Speech recognition is not supported in your browser.');\n    }\n    return () => {\n      if (recognitionRef.current) {\n        recognitionRef.current.stop();\n      }\n    };\n  }, [onResult, onError]);\n  const toggleListening = () => {\n    if (isListening) {\n      recognitionRef.current.stop();\n      setIsListening(false);\n    } else {\n      // Reset transcript when starting a new recording session\n      // Comment the next line if you want to continue from previous recording\n      // transcriptRef.current = '';\n\n      recognitionRef.current.start();\n      setIsListening(true);\n    }\n  };\n  const resetTranscript = () => {\n    transcriptRef.current = '';\n    onResult('');\n  };\n  return {\n    isListening,\n    toggleListening,\n    resetTranscript,\n    recognition: recognitionRef.current\n  };\n};\n_s(useSpeechRecognition, \"lnXNZEaUmGHHZQo7o3E7EvQ41R4=\");\nexport default useSpeechRecognition;","map":{"version":3,"names":["useState","useEffect","useRef","useSpeechRecognition","onResult","onError","_s","isListening","setIsListening","recognitionRef","transcriptRef","window","SpeechRecognition","webkitSpeechRecognition","current","continuous","interimResults","onresult","event","interimTranscript","finalTranscript","i","resultIndex","results","length","transcript","isFinal","onerror","console","error","stop","toggleListening","start","resetTranscript","recognition"],"sources":["/Users/nodokashibasaki/100DAY_DAY1/src/hooks/useSpeechRecognition.js"],"sourcesContent":["import { useState, useEffect, useRef } from 'react';\n\nconst useSpeechRecognition = ({ onResult, onError }) => {\n  const [isListening, setIsListening] = useState(false);\n  const recognitionRef = useRef(null);\n  const transcriptRef = useRef('');\n  \n  useEffect(() => {\n    if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {\n      const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;\n      recognitionRef.current = new SpeechRecognition();\n      recognitionRef.current.continuous = true;\n      recognitionRef.current.interimResults = true;\n      \n      recognitionRef.current.onresult = (event) => {\n        let interimTranscript = '';\n        let finalTranscript = transcriptRef.current;\n        \n        for (let i = event.resultIndex; i < event.results.length; i++) {\n          const transcript = event.results[i][0].transcript;\n          if (event.results[i].isFinal) {\n            finalTranscript += transcript + ' ';\n          } else {\n            interimTranscript += transcript;\n          }\n        }\n        \n        // Update the reference to maintain state between callback executions\n        transcriptRef.current = finalTranscript;\n        \n        // Call the onResult callback with the combined transcript\n        onResult(finalTranscript || interimTranscript);\n      };\n      \n      recognitionRef.current.onerror = (event) => {\n        console.error('Speech recognition error', event.error);\n        onError(event.error);\n        setIsListening(false);\n      };\n    } else {\n      onError('Speech recognition is not supported in your browser.');\n    }\n    \n    return () => {\n      if (recognitionRef.current) {\n        recognitionRef.current.stop();\n      }\n    };\n  }, [onResult, onError]);\n  \n  const toggleListening = () => {\n    if (isListening) {\n      recognitionRef.current.stop();\n      setIsListening(false);\n    } else {\n      // Reset transcript when starting a new recording session\n      // Comment the next line if you want to continue from previous recording\n      // transcriptRef.current = '';\n      \n      recognitionRef.current.start();\n      setIsListening(true);\n    }\n  };\n  \n  const resetTranscript = () => {\n    transcriptRef.current = '';\n    onResult('');\n  };\n  \n  return {\n    isListening,\n    toggleListening,\n    resetTranscript,\n    recognition: recognitionRef.current\n  };\n};\n\nexport default useSpeechRecognition;"],"mappings":";AAAA,SAASA,QAAQ,EAAEC,SAAS,EAAEC,MAAM,QAAQ,OAAO;AAEnD,MAAMC,oBAAoB,GAAGA,CAAC;EAAEC,QAAQ;EAAEC;AAAQ,CAAC,KAAK;EAAAC,EAAA;EACtD,MAAM,CAACC,WAAW,EAAEC,cAAc,CAAC,GAAGR,QAAQ,CAAC,KAAK,CAAC;EACrD,MAAMS,cAAc,GAAGP,MAAM,CAAC,IAAI,CAAC;EACnC,MAAMQ,aAAa,GAAGR,MAAM,CAAC,EAAE,CAAC;EAEhCD,SAAS,CAAC,MAAM;IACd,IAAI,yBAAyB,IAAIU,MAAM,IAAI,mBAAmB,IAAIA,MAAM,EAAE;MACxE,MAAMC,iBAAiB,GAAGD,MAAM,CAACC,iBAAiB,IAAID,MAAM,CAACE,uBAAuB;MACpFJ,cAAc,CAACK,OAAO,GAAG,IAAIF,iBAAiB,CAAC,CAAC;MAChDH,cAAc,CAACK,OAAO,CAACC,UAAU,GAAG,IAAI;MACxCN,cAAc,CAACK,OAAO,CAACE,cAAc,GAAG,IAAI;MAE5CP,cAAc,CAACK,OAAO,CAACG,QAAQ,GAAIC,KAAK,IAAK;QAC3C,IAAIC,iBAAiB,GAAG,EAAE;QAC1B,IAAIC,eAAe,GAAGV,aAAa,CAACI,OAAO;QAE3C,KAAK,IAAIO,CAAC,GAAGH,KAAK,CAACI,WAAW,EAAED,CAAC,GAAGH,KAAK,CAACK,OAAO,CAACC,MAAM,EAAEH,CAAC,EAAE,EAAE;UAC7D,MAAMI,UAAU,GAAGP,KAAK,CAACK,OAAO,CAACF,CAAC,CAAC,CAAC,CAAC,CAAC,CAACI,UAAU;UACjD,IAAIP,KAAK,CAACK,OAAO,CAACF,CAAC,CAAC,CAACK,OAAO,EAAE;YAC5BN,eAAe,IAAIK,UAAU,GAAG,GAAG;UACrC,CAAC,MAAM;YACLN,iBAAiB,IAAIM,UAAU;UACjC;QACF;;QAEA;QACAf,aAAa,CAACI,OAAO,GAAGM,eAAe;;QAEvC;QACAhB,QAAQ,CAACgB,eAAe,IAAID,iBAAiB,CAAC;MAChD,CAAC;MAEDV,cAAc,CAACK,OAAO,CAACa,OAAO,GAAIT,KAAK,IAAK;QAC1CU,OAAO,CAACC,KAAK,CAAC,0BAA0B,EAAEX,KAAK,CAACW,KAAK,CAAC;QACtDxB,OAAO,CAACa,KAAK,CAACW,KAAK,CAAC;QACpBrB,cAAc,CAAC,KAAK,CAAC;MACvB,CAAC;IACH,CAAC,MAAM;MACLH,OAAO,CAAC,sDAAsD,CAAC;IACjE;IAEA,OAAO,MAAM;MACX,IAAII,cAAc,CAACK,OAAO,EAAE;QAC1BL,cAAc,CAACK,OAAO,CAACgB,IAAI,CAAC,CAAC;MAC/B;IACF,CAAC;EACH,CAAC,EAAE,CAAC1B,QAAQ,EAAEC,OAAO,CAAC,CAAC;EAEvB,MAAM0B,eAAe,GAAGA,CAAA,KAAM;IAC5B,IAAIxB,WAAW,EAAE;MACfE,cAAc,CAACK,OAAO,CAACgB,IAAI,CAAC,CAAC;MAC7BtB,cAAc,CAAC,KAAK,CAAC;IACvB,CAAC,MAAM;MACL;MACA;MACA;;MAEAC,cAAc,CAACK,OAAO,CAACkB,KAAK,CAAC,CAAC;MAC9BxB,cAAc,CAAC,IAAI,CAAC;IACtB;EACF,CAAC;EAED,MAAMyB,eAAe,GAAGA,CAAA,KAAM;IAC5BvB,aAAa,CAACI,OAAO,GAAG,EAAE;IAC1BV,QAAQ,CAAC,EAAE,CAAC;EACd,CAAC;EAED,OAAO;IACLG,WAAW;IACXwB,eAAe;IACfE,eAAe;IACfC,WAAW,EAAEzB,cAAc,CAACK;EAC9B,CAAC;AACH,CAAC;AAACR,EAAA,CAzEIH,oBAAoB;AA2E1B,eAAeA,oBAAoB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}